//! Parser for parsing TextGenerationPipeline outputs, allows easily parsing common tags used
//! for reasoning like `<think>` as well as any common tags you want to register.
//!
//! Tags are registered simply by creating an enum with variants representing the tags you want to
//! parse. Variants are interpreted as the snake_case version of the name by default. Though you can override it
//! to be whatever you'd like using `#[tag("new-name")]`.
//!
//! Inside the crate this is mainly used to handle the tool calling loop for tool enabled models,
//! but it's also exposed publicly for end users of the crate to parse `<think>` or any custom tags
//! they might want to handle.
//!
//! # Examples
//!
//! ## Creating the Parser
//!
//! ```rust, ignore
//! // Define the enum representing the tags you want to parse
//! #[derive(XmlTag, Clone, PartialEq, Debug)]
//! enum Tags {
//!      Think, // `<think>`
//!      ToolCall, // `<tool_call>`
//! }
//!
//! // Then create the parser using the `parser()` method generated by the `XmlTag` macro
//! parser = Tags::parser();
//! ```
//!
//! ## Parsing Tokens
//!
//! ```rust, ignore
//! // As easy as passing any &str to .parse() and any iter &str to .parse_iter(),
//! let tokens = pipeline.run_iter("What is 2+2?")?;
//! let events = parser.parse_iter(tokens)?;
//! ```
//!
//! ## Handling Events
//!
//! ```rust
//! use candle_pipelines::text_generation::{Event, TagPart, XmlTag};
//!
//! #[derive(XmlTag, Clone, PartialEq, Debug)]
//! enum Tags {
//!     Think,
//! }
//!
//! let mut parser = Tags::parser();
//! let events = parser.parse("<think>hmmm 30 + 37 = 67 so I should answer 67</think>67");
//!
//! for event in events {
//!     match event {
//!         Event::Tag { tag, part } => match tag {
//!             Tags::Think => match part {
//!                 TagPart::Opened { .. } => println!("[thinking...]"),
//!                 TagPart::Content { text } => print!("{}", text),
//!                 TagPart::Closed { .. } => println!("[done]"),
//!             }
//!         },
//!         Event::Content { text } => print!("The answer is: {}", text),
//!     }
//! }
//! ```

use std::collections::{HashMap, VecDeque};

/// An event emitted by [`XmlParser`].
#[derive(Debug, Clone, PartialEq)]
pub enum Event<T: XmlTag> {
    /// Plain text outside any recognized tag (including unrecognized tags).
    Content {
        /// The text content
        text: String,
    },
    /// Any recognized registered tag, and the content within it.
    Tag {
        /// Matching variant on tag enum
        tag: T,
        /// Which part this event represents: Opened, Content, or Closed.
        part: TagPart,
    },
}

/// A fragment of a tag delivered while parsing.
///
/// Normal xml tag sequence: `Opened` → `Content` → `Closed`.
/// Self-closing elements emit only: `Opened` -> `Closed`.
#[derive(Debug, Clone, PartialEq)]
pub enum TagPart {
    /// Opening tag
    Opened {
        /// The text for Opened is just the tag. (ex. `<think>`)
        text: String,
        /// Contains the attrs if any on the tag. (ex. `<tool_call name=get_weather>`)
        attrs: HashMap<String, String>,
    },
    /// Content between tags
    Content {
        /// The text content
        text: String,
    },
    /// Closing tag
    Closed {
        /// The text for Closed is just the end tag. (ex. `</think>`)
        text: String,
        /// The full sequence, useful for parsing out tools primarily.
        element: String,
        /// Contains the attrs if any were on the opening tag.
        attrs: HashMap<String, String>,
    },
}

impl TagPart {
    /// Parses this part as a `<tool_call>` payload.
    ///
    /// Returns `Some((name, arguments))` only when this is a `Closed` part
    /// and the `element` contains valid tool_call JSON.
    ///
    /// The parser trims whitespace inside the element, parses the inner text as JSON,
    /// and expects an object with:
    /// - `"name"`: a string
    /// - `"arguments"`: any JSON value
    ///
    /// Returns `None` on any mismatch or JSON parsing/shape error.
    pub fn parse_tool_call(&self) -> Option<(String, serde_json::Value)> {
        match self {
            TagPart::Closed { element, .. } => {
                let inner = element
                    .strip_prefix("<tool_call>")?
                    .strip_suffix("</tool_call>")?
                    .trim();

                let parsed: serde_json::Value = serde_json::from_str(inner).ok()?;
                let name = parsed.get("name")?.as_str()?.to_string();
                let arguments = parsed.get("arguments")?.clone();

                Some((name, arguments))
            }
            _ => None,
        }
    }
}

/// Parser for extracting XML tags from LLM output.
///
/// Designed for parsing structured output from [`TextGenerationPipeline`], such as
/// `<think>` reasoning blocks or `<tool_call>` invocations. This is a minimal parser
/// optimized for LLM output patterns, not a general-purpose XML parser.
///
/// Define your tags as an enum with `#[derive(XmlTag)]`, then call `parser()`
/// on the enum to create a parser.
///
/// Use [`parse()`](Self::parse) for complete strings or [`parse_iter()`](Self::parse_iter)
/// for token-by-token output. See [`Event`] and [`TagPart`] for the output structure.
///
/// # Example
///
/// ```rust,ignore
/// use candle_pipelines::text_generation::{Event, TagPart, XmlTag};
///
/// #[derive(XmlTag, Clone, PartialEq, Debug)]
/// enum Tags {
///     Think,   // matches <think>
///     Answer,  // matches <answer>
/// }
///
/// let mut parser = Tags::parser();
/// for event in parser.parse("<think>reasoning</think>") {
///     match event {
///         Event::Content { text } => print!("{}", text),
///         Event::Tag { tag, part } => match tag {
///             Tags::Think => match part {
///                 TagPart::Content { text } => print!("{}", text),
///                 _ => {}
///             },
///             Tags::Answer => match part {
///                 TagPart::Closed { element, .. } => println!("{}", element),
///                 _ => {}
///             },
///         },
///     }
/// }
/// ```
///
/// # Limitations
///
/// - Tracks one open tag at a time; does not support nested tags.
/// - Tags inside another tag's content are treated as literal text.
/// - Does not handle namespaces, entities, comments, CDATA, or processing instructions.
/// - Malformed or mismatched tags are emitted as plain text.
#[derive(Debug, Clone)]
pub struct XmlParser<T: XmlTag> {
    state: ParserState<T>,
}

impl<T: XmlTag> Default for XmlParser<T> {
    fn default() -> Self {
        Self::new()
    }
}

/// Public
impl<T: XmlTag> XmlParser<T> {
    /// Parses `text` and returns all events.
    ///
    /// For token-by-token parsing, use [`parse_iter`](Self::parse_iter) instead.
    pub fn parse(&mut self, text: &str) -> Vec<Event<T>> {
        self.reset();
        let mut events = Vec::new();

        for c in text.chars() {
            self.process_char(c, &mut events);
        }

        self.flush_internal(&mut events);
        events
    }

    /// Wraps a token iterator and yields parsing events as they become available.
    ///
    /// Events are emitted as tokens arrive, so `Content` events may be split across
    /// multiple chunks. Concatenate adjacent payloads if you need the full content.
    ///
    /// # Errors
    ///
    /// If the inner iterator yields an error, it is propagated after any pending events.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// use candle_pipelines::text_generation::{Event, TagPart, XmlTag};
    ///
    /// #[derive(XmlTag, Clone, PartialEq, Debug)]
    /// enum Tags { Think }
    ///
    /// let parser = Tags::parser();
    /// let tokens = pipeline.run_iter("...")?;
    ///
    /// for event in parser.parse_iter(tokens) {
    ///     match event? {
    ///         Event::Content { text } => print!("{}", text),
    ///         Event::Tag { tag: Tags::Think, part } => match part {
    ///             TagPart::Content { text } => print!("{}", text),
    ///             _ => {}
    ///         },
    ///     }
    /// }
    /// ```
    pub fn parse_iter<I>(&self, iter: I) -> impl Iterator<Item = crate::error::Result<Event<T>>>
    where
        I: Iterator<Item = crate::error::Result<String>>,
    {
        EventIterator::new(self.clone(), iter)
    }
}

/// Internal
impl<T: XmlTag> XmlParser<T> {
    /// Creates a new parser instance.
    ///
    /// Hidden from public docs because users should use `TagEnum::parser()` instead.
    /// Not pub(crate) only because the `XmlTag` derive macro generates code that calls it.
    #[doc(hidden)]
    pub fn new() -> Self {
        Self {
            state: ParserState::default(),
        }
    }

    /// Clears any partial state from previous parsing.
    ///
    /// Both [`parse`](Self::parse) and [`parse_iter`](Self::parse_iter) call this automatically.
    pub(crate) fn reset(&mut self) {
        self.state = ParserState::default();
    }
}

#[doc(hidden)]
pub trait XmlTag: Sized + Clone + PartialEq + std::fmt::Debug {
    fn from_tag_str(s: &str) -> Option<Self>;
    fn as_tag_str(&self) -> &'static str;
}

/// Iterator that converts a token stream into [`Event`] values.
pub(crate) struct EventIterator<T: XmlTag, I> {
    parser: XmlParser<T>,
    inner: I,
    buffer: VecDeque<Event<T>>,
    flushed: bool,
    pending_error: Option<crate::error::PipelineError>,
}

impl<T: XmlTag, I> Iterator for EventIterator<T, I>
where
    I: Iterator<Item = crate::error::Result<String>>,
{
    type Item = crate::error::Result<Event<T>>;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(event) = self.buffer.pop_front() {
            return Some(Ok(event));
        }

        if let Some(e) = self.pending_error.take() {
            return Some(Err(e));
        }

        if self.flushed {
            return None;
        }

        for result in self.inner.by_ref() {
            match result {
                Ok(token) => {
                    let events = self.parser.parse_token(&token);
                    if !events.is_empty() {
                        self.buffer.extend(events);
                        return Some(Ok(self.buffer.pop_front().unwrap()));
                    }
                }
                Err(e) => {
                    let flush_events = self.parser.flush();
                    self.buffer.extend(flush_events);
                    self.flushed = true;
                    self.pending_error = Some(e);

                    if let Some(event) = self.buffer.pop_front() {
                        return Some(Ok(event));
                    }
                    return Some(Err(self.pending_error.take().unwrap()));
                }
            }
        }

        if !self.flushed {
            self.flushed = true;
            let events = self.parser.flush();
            if !events.is_empty() {
                self.buffer.extend(events);
                return Some(Ok(self.buffer.pop_front().unwrap()));
            }
        }

        None
    }
}

impl<T: XmlTag, I> EventIterator<T, I> {
    fn new(mut parser: XmlParser<T>, iter: I) -> Self {
        parser.reset();
        Self {
            parser,
            inner: iter,
            buffer: VecDeque::new(),
            flushed: false,
            pending_error: None,
        }
    }
}

impl<T: XmlTag> Event<T> {
    /// Creates a plain content event (text outside any tag).
    pub(crate) fn content(text: impl Into<String>) -> Self {
        Event::Content { text: text.into() }
    }

    /// Creates an Opened event for a tag.
    pub(crate) fn opened(tag: T, text: impl Into<String>, attrs: HashMap<String, String>) -> Self {
        Event::Tag {
            tag,
            part: TagPart::Opened {
                text: text.into(),
                attrs,
            },
        }
    }

    /// Creates a Content event for a tag.
    pub(crate) fn tag_content(tag: T, text: impl Into<String>) -> Self {
        Event::Tag {
            tag,
            part: TagPart::Content { text: text.into() },
        }
    }

    /// Creates a Closed event for a tag.
    pub(crate) fn closed(
        tag: T,
        text: impl Into<String>,
        element: impl Into<String>,
        attrs: HashMap<String, String>,
    ) -> Self {
        Event::Tag {
            tag,
            part: TagPart::Closed {
                text: text.into(),
                element: element.into(),
                attrs,
            },
        }
    }
}

impl<T: XmlTag> XmlParser<T> {
    /// Parses a token and returns any newly available events.
    pub(crate) fn parse_token(&mut self, token: &str) -> Vec<Event<T>> {
        let mut events = Vec::new();

        for c in token.chars() {
            self.process_char(c, &mut events);
        }

        if let Some(ref mut open) = self.state.open_tag {
            let total_len = open.content.len();
            if total_len > open.emitted_len {
                let new_slice = &open.content[open.emitted_len..];
                if !new_slice.is_empty() {
                    events.push(Event::tag_content(open.tag.clone(), new_slice));
                }
                open.emitted_len = total_len;
            }
        } else {
            let current_len = self.state.content_buffer.len();
            if current_len > self.state.emitted_top_len {
                let new_slice = &self.state.content_buffer[self.state.emitted_top_len..];
                if !new_slice.is_empty() {
                    events.push(Event::content(new_slice));
                }
                self.state.content_buffer.clear();
                self.state.emitted_top_len = 0;
            }
        }

        events
    }

    fn process_char(&mut self, c: char, out: &mut Vec<Event<T>>) {
        match c {
            '<' => {
                self.state.in_tag = true;
                self.state.tag_buffer.clear();
                self.state.tag_buffer.push(c);
            }
            '>' if self.state.in_tag => {
                self.state.tag_buffer.push(c);
                self.state.in_tag = false;

                let tag_content = std::mem::take(&mut self.state.tag_buffer);
                self.handle_tag(&tag_content, out);
            }
            _ if self.state.in_tag => {
                self.state.tag_buffer.push(c);
            }
            _ => {
                if let Some(ref mut open) = self.state.open_tag {
                    open.content.push(c);
                } else {
                    self.state.content_buffer.push(c);
                }
            }
        }
    }

    fn handle_tag(&mut self, tag_content: &str, out: &mut Vec<Event<T>>) {
        if let Some(tag_name) = Self::parse_tag_name(tag_content) {
            let trimmed_name = tag_name.trim();

            // Try to parse as a known tag
            if let Some(tag) = T::from_tag_str(trimmed_name) {
                let tag_str = tag.as_tag_str();

                if tag_content.starts_with("</") {
                    // Closing tag
                    if let Some(ref open) = self.state.open_tag {
                        if open.tag.as_tag_str() == tag_str {
                            let open = self.state.open_tag.take().unwrap();

                            if open.content.len() > open.emitted_len {
                                let remaining = &open.content[open.emitted_len..];
                                if !remaining.is_empty() {
                                    out.push(Event::tag_content(open.tag.clone(), remaining));
                                }
                            }

                            let closing_tag = format!("</{}>", tag_str);
                            let full_element =
                                format!("<{}>{}</{}>", tag_str, open.content, tag_str);
                            out.push(Event::closed(
                                open.tag,
                                closing_tag,
                                full_element,
                                open.attrs,
                            ));
                        } else {
                            // Mismatched close - treat as content
                            if let Some(ref mut open) = self.state.open_tag {
                                open.content.push_str(tag_content);
                            }
                        }
                    } else {
                        self.state.content_buffer.push_str(tag_content);
                    }
                } else if tag_content.ends_with("/>") {
                    // Self-closing tag - only emit Closed
                    if self.state.open_tag.is_none() {
                        if !self.state.content_buffer.is_empty() {
                            let content = &self.state.content_buffer[self.state.emitted_top_len..];
                            if !content.is_empty() {
                                out.push(Event::content(content));
                            }
                            self.state.emitted_top_len = self.state.content_buffer.len();
                        }

                        let attrs = Self::parse_attributes(tag_content);
                        // For self-closing, text and element are the same
                        out.push(Event::closed(
                            tag,
                            tag_content.to_string(),
                            tag_content.to_string(),
                            attrs,
                        ));
                    } else if let Some(ref mut open) = self.state.open_tag {
                        open.content.push_str(tag_content);
                    }
                } else {
                    // Opening tag
                    if self.state.open_tag.is_none() {
                        if !self.state.content_buffer.is_empty() {
                            let content = &self.state.content_buffer[self.state.emitted_top_len..];
                            if !content.is_empty() {
                                out.push(Event::content(content));
                            }
                            self.state.emitted_top_len = self.state.content_buffer.len();
                        }

                        let attrs = Self::parse_attributes(tag_content);
                        self.state.open_tag = Some(OpenTag {
                            tag: tag.clone(),
                            content: String::new(),
                            attrs: attrs.clone(),
                            emitted_len: 0,
                        });

                        out.push(Event::opened(tag, tag_content.to_string(), attrs));
                    } else if let Some(ref mut open) = self.state.open_tag {
                        open.content.push_str(tag_content);
                    }
                }
            } else if let Some(ref mut open) = self.state.open_tag {
                open.content.push_str(tag_content);
            } else {
                self.state.content_buffer.push_str(tag_content);
            }
        } else if let Some(ref mut open) = self.state.open_tag {
            open.content.push_str(tag_content);
        } else {
            self.state.content_buffer.push_str(tag_content);
        }
    }

    fn parse_tag_name(tag_content: &str) -> Option<&str> {
        if tag_content.len() < 3 || !tag_content.starts_with('<') || !tag_content.ends_with('>') {
            return None;
        }

        let inner = &tag_content[1..tag_content.len() - 1];

        if let Some(name) = inner.strip_prefix('/') {
            let trimmed_end = name.trim_end();
            if trimmed_end.is_empty() {
                None
            } else {
                Some(trimmed_end)
            }
        } else {
            let trimmed_end = inner.trim_end_matches('/').split_whitespace().next()?;
            let leading_ws = inner.len() - inner.trim_start().len();
            let name_with_leading = &inner[..leading_ws + trimmed_end.len()];
            if let Some(stripped) = name_with_leading.strip_suffix('/') {
                Some(stripped)
            } else {
                Some(name_with_leading)
            }
        }
    }

    /// Parses attributes from an opening or self-closing tag.
    fn parse_attributes(tag_content: &str) -> HashMap<String, String> {
        let mut attrs = HashMap::new();

        if tag_content.len() < 3 {
            return attrs;
        }
        let inner = &tag_content[1..tag_content.len() - 1];

        let after_name = match inner.split_whitespace().next() {
            Some(name) => {
                let name_end = inner.find(name).unwrap_or(0) + name.len();
                &inner[name_end..]
            }
            None => return attrs,
        };

        let mut chars = after_name.chars().peekable();

        while let Some(c) = chars.next() {
            if c.is_whitespace() {
                continue;
            }

            let mut attr_name = String::new();
            attr_name.push(c);
            while let Some(&next) = chars.peek() {
                if next == '=' || next.is_whitespace() {
                    break;
                }
                attr_name.push(chars.next().unwrap());
            }

            while let Some(&next) = chars.peek() {
                if next == '=' {
                    chars.next();
                    break;
                } else if next.is_whitespace() {
                    chars.next();
                } else {
                    break;
                }
            }

            let mut attr_value = String::new();

            while let Some(&next) = chars.peek() {
                if !next.is_whitespace() {
                    break;
                }
                chars.next();
            }

            if let Some(&quote) = chars.peek() {
                if quote == '"' || quote == '\'' {
                    chars.next();
                    for c in chars.by_ref() {
                        if c == quote {
                            break;
                        }
                        attr_value.push(c);
                    }
                } else {
                    while let Some(&next) = chars.peek() {
                        if next.is_whitespace() || next == '/' {
                            break;
                        }
                        attr_value.push(chars.next().unwrap());
                    }
                }
            }

            if !attr_name.is_empty() {
                attrs.insert(attr_name, attr_value);
            }
        }

        attrs
    }

    /// Flushes any buffered input and returns the resulting events.
    pub(crate) fn flush(&mut self) -> Vec<Event<T>> {
        let mut events = Vec::new();
        self.flush_internal(&mut events);
        events
    }

    fn flush_internal(&mut self, out: &mut Vec<Event<T>>) {
        if self.state.in_tag && !self.state.tag_buffer.is_empty() {
            let partial = std::mem::take(&mut self.state.tag_buffer);
            if let Some(ref mut open) = self.state.open_tag {
                open.content.push_str(&partial);
            } else {
                self.state.content_buffer.push_str(&partial);
            }
            self.state.in_tag = false;
        }

        if self.state.content_buffer.len() > self.state.emitted_top_len {
            let remaining = &self.state.content_buffer[self.state.emitted_top_len..];
            if !remaining.is_empty() {
                out.push(Event::content(remaining));
            }
        }
        self.state.content_buffer.clear();
        self.state.emitted_top_len = 0;

        if let Some(open) = self.state.open_tag.take() {
            if open.content.len() > open.emitted_len {
                let remaining = &open.content[open.emitted_len..];
                if !remaining.is_empty() {
                    out.push(Event::tag_content(open.tag, remaining));
                }
            }
        }
    }
}

#[derive(Debug, Clone)]
struct OpenTag<T: XmlTag> {
    tag: T,
    content: String,
    attrs: HashMap<String, String>,
    emitted_len: usize,
}

#[derive(Debug, Clone)]
struct ParserState<T: XmlTag> {
    open_tag: Option<OpenTag<T>>,
    content_buffer: String,
    tag_buffer: String,
    in_tag: bool,
    emitted_top_len: usize,
}

impl<T: XmlTag> Default for ParserState<T> {
    fn default() -> Self {
        Self {
            open_tag: None,
            content_buffer: String::new(),
            tag_buffer: String::new(),
            in_tag: false,
            emitted_top_len: 0,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ============ Test Tag Enums ============

    /// Single tag for basic tests
    #[derive(Debug, Clone, PartialEq)]
    enum Think {
        Think,
    }

    impl XmlTag for Think {
        fn from_tag_str(s: &str) -> Option<Self> {
            match s.trim() {
                "think" => Some(Self::Think),
                _ => None,
            }
        }
        fn as_tag_str(&self) -> &'static str {
            "think"
        }
    }

    /// Two tags for multi-tag tests
    #[derive(Debug, Clone, PartialEq)]
    enum ThinkAnswer {
        Think,
        Answer,
    }

    impl XmlTag for ThinkAnswer {
        fn from_tag_str(s: &str) -> Option<Self> {
            match s.trim() {
                "think" => Some(Self::Think),
                "answer" => Some(Self::Answer),
                _ => None,
            }
        }
        fn as_tag_str(&self) -> &'static str {
            match self {
                Self::Think => "think",
                Self::Answer => "answer",
            }
        }
    }

    /// Just answer tag (for unregistered tag tests)
    #[derive(Debug, Clone, PartialEq)]
    enum Answer {
        Answer,
    }

    impl XmlTag for Answer {
        fn from_tag_str(s: &str) -> Option<Self> {
            match s.trim() {
                "answer" => Some(Self::Answer),
                _ => None,
            }
        }
        fn as_tag_str(&self) -> &'static str {
            "answer"
        }
    }

    /// Fn tag for attribute tests
    #[derive(Debug, Clone, PartialEq)]
    enum Fn {
        Fn,
    }

    impl XmlTag for Fn {
        fn from_tag_str(s: &str) -> Option<Self> {
            match s.trim() {
                "fn" => Some(Self::Fn),
                _ => None,
            }
        }
        fn as_tag_str(&self) -> &'static str {
            "fn"
        }
    }

    /// FunctionCall tag
    #[derive(Debug, Clone, PartialEq)]
    enum FunctionCall {
        FunctionCall,
    }

    impl XmlTag for FunctionCall {
        fn from_tag_str(s: &str) -> Option<Self> {
            match s.trim() {
                "function_call" => Some(Self::FunctionCall),
                _ => None,
            }
        }
        fn as_tag_str(&self) -> &'static str {
            "function_call"
        }
    }

    /// ToolCall tag
    #[derive(Debug, Clone, PartialEq)]
    enum ToolCall {
        ToolCall,
    }

    impl XmlTag for ToolCall {
        fn from_tag_str(s: &str) -> Option<Self> {
            match s.trim() {
                "tool_call" => Some(Self::ToolCall),
                _ => None,
            }
        }
        fn as_tag_str(&self) -> &'static str {
            "tool_call"
        }
    }

    // ============ Helper Functions ============

    /// Check if event is Content (plain text)
    fn is_content<T: XmlTag>(event: &Event<T>) -> bool {
        matches!(event, Event::Content { .. })
    }

    /// Check if event is a tag event with specific tag
    fn is_tag<T: XmlTag + PartialEq>(event: &Event<T>, expected_tag: &T) -> bool {
        matches!(event, Event::Tag { tag, .. } if tag == expected_tag)
    }

    /// Check if event is Opened
    fn is_opened<T: XmlTag>(event: &Event<T>) -> bool {
        matches!(
            event,
            Event::Tag {
                part: TagPart::Opened { .. },
                ..
            }
        )
    }

    /// Check if event is TagPart::Content
    fn is_tag_content<T: XmlTag>(event: &Event<T>) -> bool {
        matches!(
            event,
            Event::Tag {
                part: TagPart::Content { .. },
                ..
            }
        )
    }

    /// Check if event is Closed
    fn is_closed<T: XmlTag>(event: &Event<T>) -> bool {
        matches!(
            event,
            Event::Tag {
                part: TagPart::Closed { .. },
                ..
            }
        )
    }

    /// Get text from event (works for both Content and Tag parts)
    fn get_text<T: XmlTag>(event: &Event<T>) -> &str {
        match event {
            Event::Content { text } => text,
            Event::Tag { part, .. } => match part {
                TagPart::Opened { text, .. } => text,
                TagPart::Content { text } => text,
                TagPart::Closed { text, .. } => text,
            },
        }
    }

    /// Get element from Closed event
    fn get_element<T: XmlTag>(event: &Event<T>) -> Option<&str> {
        match event {
            Event::Tag {
                part: TagPart::Closed { element, .. },
                ..
            } => Some(element),
            _ => None,
        }
    }

    /// Get attrs from event
    fn get_attrs<T: XmlTag>(event: &Event<T>) -> Option<&HashMap<String, String>> {
        match event {
            Event::Tag { part, .. } => match part {
                TagPart::Opened { attrs, .. } => Some(attrs),
                TagPart::Closed { attrs, .. } => Some(attrs),
                _ => None,
            },
            _ => None,
        }
    }

    fn assert_attr<T: XmlTag>(event: &Event<T>, key: &str, expected: &str) {
        let attrs = get_attrs(event).expect("expected attributes");
        assert_eq!(attrs.get(key).map(String::as_str), Some(expected));
    }

    // ============ Tests ============

    #[test]
    fn test_plain_text_only_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "Regular content";
        let events = parser.parse(text);

        assert_eq!(events.len(), 1);
        assert!(is_content(&events[0]));
        assert_eq!(get_text(&events[0]), "Regular content");
    }

    #[test]
    fn test_empty_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "";
        let events = parser.parse(text);

        assert_eq!(events.len(), 0);
    }

    #[test]
    fn test_whitespace_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "  ";
        let events = parser.parse(text);

        assert_eq!(events.len(), 1);
        assert!(is_content(&events[0]));
        assert_eq!(get_text(&events[0]), "  ");
    }

    #[test]
    fn test_single_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hello world</think>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 3);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello world");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
        assert_eq!(get_element(&events[2]), Some(text));
    }

    #[test]
    fn test_plain_text_and_single_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hello world</think>Regular content";
        let events = parser.parse(text);

        assert_eq!(events.len(), 4);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello world");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
        assert!(is_content(&events[3]));
        assert_eq!(get_text(&events[3]), "Regular content");
    }

    #[test]
    fn test_unicode_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();
        let text = "<think>你好世界</think>普通内容";
        let events = parser.parse(text);

        assert_eq!(events.len(), 4);
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "你好世界");
        assert!(is_content(&events[3]));
        assert_eq!(get_text(&events[3]), "普通内容");
    }

    #[test]
    fn test_plain_text_before_and_after_single_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "How are <think>Hello world</think>you doing today?";
        let events = parser.parse(text);

        assert_eq!(events.len(), 5);
        assert!(is_content(&events[0]));
        assert_eq!(get_text(&events[0]), "How are ");
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_opened(&events[1]));
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_tag_content(&events[2]));
        assert_eq!(get_text(&events[2]), "Hello world");
        assert!(is_tag(&events[3], &Think::Think));
        assert!(is_closed(&events[3]));
        assert!(is_content(&events[4]));
        assert_eq!(get_text(&events[4]), "you doing today?");

        let plain: String = events
            .iter()
            .filter(|e| is_content(e))
            .map(get_text)
            .collect();
        assert_eq!(plain, "How are you doing today?");
    }

    #[test]
    fn test_multiple_tags_parsing() {
        let mut parser = XmlParser::<ThinkAnswer>::new();

        let text = "<think>Hm the answer to 1 + 1 is 2</think><answer>2</answer>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 6);
        assert!(is_tag(&events[0], &ThinkAnswer::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &ThinkAnswer::Think));
        assert!(is_tag_content(&events[1]));
        assert!(is_tag(&events[2], &ThinkAnswer::Think));
        assert!(is_closed(&events[2]));
        assert!(is_tag(&events[3], &ThinkAnswer::Answer));
        assert!(is_opened(&events[3]));
        assert!(is_tag(&events[4], &ThinkAnswer::Answer));
        assert!(is_tag_content(&events[4]));
        assert_eq!(get_text(&events[4]), "2");
        assert!(is_tag(&events[5], &ThinkAnswer::Answer));
        assert!(is_closed(&events[5]));
    }

    #[test]
    fn test_multiple_same_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hello world</think><think>Regular content</think>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 6);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello world");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
        assert!(is_tag(&events[3], &Think::Think));
        assert!(is_opened(&events[3]));
        assert!(is_tag(&events[4], &Think::Think));
        assert!(is_tag_content(&events[4]));
        assert_eq!(get_text(&events[4]), "Regular content");
        assert!(is_tag(&events[5], &Think::Think));
        assert!(is_closed(&events[5]));
    }

    #[test]
    fn test_empty_tags_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think></think>Regular content";
        let events = parser.parse(text);

        assert_eq!(events.len(), 3);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_closed(&events[1]));
        assert!(is_content(&events[2]));
        assert_eq!(get_text(&events[2]), "Regular content");
    }

    #[test]
    fn test_unregistered_tag_parsing() {
        // Using Answer enum - <think> is not registered, only <answer>
        let mut parser = XmlParser::<Answer>::new();

        let text = "<think>Hm the answer to 1 + 1 is 2</think><answer>2</answer>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 4);
        // <think> is not recognized, so it becomes output
        assert!(is_content(&events[0]));
        assert_eq!(
            get_text(&events[0]),
            "<think>Hm the answer to 1 + 1 is 2</think>"
        );
        assert!(is_tag(&events[1], &Answer::Answer));
        assert!(is_opened(&events[1]));
        assert!(is_tag(&events[2], &Answer::Answer));
        assert!(is_tag_content(&events[2]));
        assert_eq!(get_text(&events[2]), "2");
        assert!(is_tag(&events[3], &Answer::Answer));
        assert!(is_closed(&events[3]));
    }

    #[test]
    fn test_self_closing_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think/>Regular Content<think />";
        let events = parser.parse(text);

        // Self-closing tags only emit Closed (not Start+End)
        assert_eq!(events.len(), 3);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_closed(&events[0]));
        assert_eq!(get_element(&events[0]), Some("<think/>"));
        assert!(is_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Regular Content");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
        assert_eq!(get_element(&events[2]), Some("<think />"));
    }

    #[test]
    fn test_is_greedy_parsing() {
        let mut parser = XmlParser::<ThinkAnswer>::new();

        let text = "<think>Hm the answer to 1 + 1 is 2 so I should output <answer> tags containing 2 like <answer>2</answer>, I'll do that now</think><answer>2</answer>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 6);
        assert!(is_tag(&events[0], &ThinkAnswer::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &ThinkAnswer::Think));
        assert!(is_tag_content(&events[1]));
        assert!(is_tag(&events[2], &ThinkAnswer::Think));
        assert!(is_closed(&events[2]));
        assert!(is_tag(&events[3], &ThinkAnswer::Answer));
        assert!(is_opened(&events[3]));
        assert!(is_tag(&events[4], &ThinkAnswer::Answer));
        assert!(is_tag_content(&events[4]));
        assert_eq!(get_text(&events[4]), "2");
        assert!(is_tag(&events[5], &ThinkAnswer::Answer));
        assert!(is_closed(&events[5]));
    }

    #[test]
    fn test_greedy_multiple_same_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hello world<think>Regular content</think></think>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 4);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello world<think>Regular content");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
        assert!(is_content(&events[3]));
        assert_eq!(get_text(&events[3]), "</think>");
    }

    #[test]
    fn test_greedy_multiple_same_open_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hello world<think> Regular content</think>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 3);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello world<think> Regular content");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
    }

    #[test]
    fn test_mismatched_close_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hm I think the answer to 1 + 1 is 2</answer>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 2);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(
            get_text(&events[1]),
            "Hm I think the answer to 1 + 1 is 2</answer>"
        );
    }

    #[test]
    fn test_unclosed_tag_parsing() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hm I think the answer to 1 + 1 is 2";
        let events = parser.parse(text);

        assert_eq!(events.len(), 2);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hm I think the answer to 1 + 1 is 2");
    }

    #[test]
    fn test_empty_tag_name() {
        let mut parser = XmlParser::<Think>::new();

        let text = "hello <> world </>";
        let events = parser.parse(text);

        assert_eq!(events.len(), 1);
        assert!(is_content(&events[0]));
        assert_eq!(get_text(&events[0]), "hello <> world </>");
    }

    #[test]
    fn test_reset_clears_parser_state() {
        let mut parser = XmlParser::<ThinkAnswer>::new();

        parser.parse_token("<thi");
        parser.parse_token("nk>partial content");
        parser.parse_token(" more");
        parser.reset();

        let mut events = parser.parse_token("<answer>42</answer>");
        events.extend(parser.flush());

        assert_eq!(events.len(), 3);
        assert!(is_tag(&events[0], &ThinkAnswer::Answer));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &ThinkAnswer::Answer));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "42");
        assert!(is_tag(&events[2], &ThinkAnswer::Answer));
        assert!(is_closed(&events[2]));
    }

    #[test]
    fn test_no_attributes_returns_empty() {
        let mut parser = XmlParser::<Think>::new();

        let text = "<think>Hello world</think>Regular content";
        let events = parser.parse(text);

        assert!(is_tag(&events[0], &Think::Think));
        assert!(get_attrs(&events[0]).unwrap().is_empty());
    }

    #[test]
    fn test_attribute_parsing_variants() {
        let cases = [
            // (input, attr_key, expected_value)
            ("<fn name=get_weather>x</fn>", "name", "get_weather"), // no quotes
            ("<fn name=\"get_weather\">x</fn>", "name", "get_weather"), // double quotes
            ("<fn name='get_weather'>x</fn>", "name", "get_weather"), // single quotes
            ("<fn name = get_weather>x</fn>", "name", "get_weather"), // spaces around =
            ("<fn name=\"get weather\">x</fn>", "name", "get weather"), // space in value
            ("<fn name=\"unterminated>x</fn>", "name", "unterminated"), // unterminated quote
        ];

        for (input, key, expected) in cases {
            let mut parser = XmlParser::<Fn>::new();
            let events = parser.parse(input);
            assert_attr(&events[0], key, expected);
        }
    }

    #[test]
    fn test_attribute_boolean() {
        let mut parser = XmlParser::<Fn>::new();
        let events = parser.parse("<fn disabled>x</fn>");
        assert!(get_attrs(&events[0]).unwrap().contains_key("disabled"));
    }

    #[test]
    fn test_attributes_self_closing() {
        let mut parser = XmlParser::<Fn>::new();
        let events = parser.parse("<fn name=test/>");
        assert_attr(&events[0], "name", "test");
    }

    #[test]
    fn test_multiple_attributes() {
        let mut parser = XmlParser::<Fn>::new();
        let events = parser.parse("<fn name='get_weather' id=0>x</fn>");

        assert_attr(&events[0], "name", "get_weather");
        assert_attr(&events[0], "id", "0");
    }

    #[test]
    fn test_attributes_persist_across_tag_sequence() {
        let mut parser = XmlParser::<FunctionCall>::new();

        let text = "<function_call name=test>content</function_call>";
        let events = parser.parse(text);

        // Attributes are available on Opened and Closed events (not Content)
        for event in &events {
            if is_tag(event, &FunctionCall::FunctionCall) && (is_opened(event) || is_closed(event))
            {
                assert_attr(event, "name", "test");
            }
        }
    }

    #[test]
    fn test_attribute_returns_none_for_plain_content() {
        let mut parser = XmlParser::<Think>::new();

        let text = "Regular content";
        let events = parser.parse(text);

        assert_eq!(events.len(), 1);
        assert!(is_content(&events[0]));
        assert!(get_attrs(&events[0]).is_none());
    }

    #[test]
    fn test_iter_attributes_preserved() {
        let parser = XmlParser::<FunctionCall>::new();

        let tokens = vec![
            Ok("<function_call na".to_string()),
            Ok("me=get_weather>Tokyo</function_call>".to_string()),
        ];

        let events: Vec<Event<FunctionCall>> = parser
            .parse_iter(tokens.into_iter())
            .map(|r| r.unwrap())
            .collect();

        assert!(is_tag(&events[0], &FunctionCall::FunctionCall));
        assert_attr(&events[0], "name", "get_weather");
    }

    #[test]
    fn test_iter_greedy_multiple_same_tag_parsing() {
        let parser = XmlParser::<Think>::new();

        let tokens = vec![
            Ok("<think>Hello ".to_string()),
            Ok("world<think> Regular content</think>".to_string()),
            Ok("</think>".to_string()),
        ];

        let events: Vec<Event<Think>> = parser
            .parse_iter(tokens.into_iter())
            .map(|r| r.unwrap())
            .collect();

        assert_eq!(events.len(), 5);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello ");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_tag_content(&events[2]));
        assert_eq!(get_text(&events[2]), "world<think> Regular content");
        assert!(is_tag(&events[3], &Think::Think));
        assert!(is_closed(&events[3]));
        assert!(is_content(&events[4]));
        assert_eq!(get_text(&events[4]), "</think>");
    }

    #[test]
    fn test_iter_greedy_multiple_same_open_tag_parsing() {
        let parser = XmlParser::<Think>::new();

        let tokens = vec![
            Ok("<think>Hello ".to_string()),
            Ok("world<think> Regular content".to_string()),
            Ok("</think>".to_string()),
        ];

        let events: Vec<Event<Think>> = parser
            .parse_iter(tokens.into_iter())
            .map(|r| r.unwrap())
            .collect();

        assert_eq!(events.len(), 4);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[3], &Think::Think));
        assert!(is_closed(&events[3]));
    }

    #[test]
    fn test_iter_split_open_tag_parsing() {
        let parser = XmlParser::<Think>::new();

        let tokens = vec![
            Ok("<".to_string()),
            Ok("think>Hello world</think>".to_string()),
        ];

        let events: Vec<Event<Think>> = parser
            .parse_iter(tokens.into_iter())
            .map(|r| r.unwrap())
            .collect();

        assert_eq!(events.len(), 3);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello world");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
    }

    #[test]
    fn test_iter_split_close_tag_parsing() {
        let parser = XmlParser::<Think>::new();

        let tokens = vec![
            Ok("<".to_string()),
            Ok("think>Hello world</".to_string()),
            Ok("think>".to_string()),
        ];

        let events: Vec<Event<Think>> = parser
            .parse_iter(tokens.into_iter())
            .map(|r| r.unwrap())
            .collect();

        assert_eq!(events.len(), 3);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello world");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_closed(&events[2]));
    }

    #[test]
    fn test_iter_split_content_in_tag_parsing() {
        let parser = XmlParser::<Think>::new();

        let tokens = vec![
            Ok("<".to_string()),
            Ok("think>Hello ".to_string()),
            Ok("world</think>".to_string()),
        ];
        let events: Vec<Event<Think>> = parser
            .parse_iter(tokens.into_iter())
            .map(|r| r.unwrap())
            .collect();

        assert_eq!(events.len(), 4);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "Hello ");
        assert!(is_tag(&events[2], &Think::Think));
        assert!(is_tag_content(&events[2]));
        assert_eq!(get_text(&events[2]), "world");
        assert!(is_tag(&events[3], &Think::Think));
        assert!(is_closed(&events[3]));
    }

    #[test]
    fn test_iter_char_by_char() {
        let parser = XmlParser::<Think>::new();

        let input = "<think>Hello world</think>";
        let tokens: Vec<Result<String, crate::error::PipelineError>> =
            input.chars().map(|c| Ok(c.to_string())).collect();
        let events: Vec<Event<Think>> = parser
            .parse_iter(tokens.into_iter())
            .map(|r| r.unwrap())
            .collect();

        // Should have Opened, many Content events (one per char), and Closed
        assert!(events.len() >= 3);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(events.last().unwrap(), &Think::Think));
        assert!(is_closed(events.last().unwrap()));
    }

    #[test]
    fn test_partial_tag_at_end_emitted() {
        let mut parser = XmlParser::<Think>::new();

        let text = "hello <think";
        let events = parser.parse(text);

        assert_eq!(events.len(), 1);
        assert!(is_content(&events[0]));
        assert_eq!(get_text(&events[0]), "hello <think");
    }

    #[test]
    fn test_partial_tag_inside_registered_tag() {
        let mut parser = XmlParser::<Think>::new();
        let events = parser.parse("<think>hi <ans");

        assert_eq!(events.len(), 2);
        assert!(is_tag(&events[0], &Think::Think));
        assert!(is_opened(&events[0]));
        assert!(is_tag(&events[1], &Think::Think));
        assert!(is_tag_content(&events[1]));
        assert_eq!(get_text(&events[1]), "hi <ans");
    }

    #[test]
    fn test_parse_token_no_double_emit() {
        let mut parser = XmlParser::<Think>::new();

        let events1 = parser.parse_token("hello ");
        let events2 = parser.parse_token("world");
        let events3 = parser.flush();

        let all_content: String = events1
            .iter()
            .chain(events2.iter())
            .chain(events3.iter())
            .map(get_text)
            .collect();

        assert_eq!(all_content, "hello world");
    }

    #[test]
    fn test_parse_token_flush_trailing_plain() {
        let mut parser = XmlParser::<Think>::new();

        let _ = parser.parse_token("<think>content</think>");
        let events1 = parser.parse_token("trailing");
        let events2 = parser.flush();

        let trailing_count = events1
            .iter()
            .chain(events2.iter())
            .filter(|e| is_content(e) && get_text(e).contains("trailing"))
            .count();

        assert_eq!(trailing_count, 1);
    }

    #[test]
    fn test_parse_tool_call_valid() {
        let mut parser = XmlParser::<ToolCall>::new();

        let text =
            r#"<tool_call>{"name": "get_weather", "arguments": {"city": "Tokyo"}}</tool_call>"#;
        let events = parser.parse(text);

        let closed_event = events.iter().find(|e| is_closed(e)).unwrap();
        let result = match closed_event {
            Event::Tag { part, .. } => part.parse_tool_call(),
            _ => None,
        };

        assert!(result.is_some());
        let (name, args) = result.unwrap();
        assert_eq!(name, "get_weather");
        assert_eq!(args["city"], "Tokyo");
    }

    #[test]
    fn test_parse_tool_call_invalid() {
        let mut parser = XmlParser::<ToolCall>::new();

        let text = "<tool_call>not valid json</tool_call>";
        let events = parser.parse(text);

        let closed_event = events.iter().find(|e| is_closed(e)).unwrap();
        let result = match closed_event {
            Event::Tag { part, .. } => part.parse_tool_call(),
            _ => None,
        };

        assert!(result.is_none());
    }
}
